"""Logan Graphical Analysis Model for Reversible Tracer BindingThis module implements the Logan plot for quantifying reversible radiotracer bindingin dynamic PET imaging. It provides transformation methods both with and withoutblood volume correction.The core implementation follows the Logan graphical linearization technique to estimatethe volume of distribution (VT) of tracers in tissue.Functions:- transform_without_blood_correction- transform_with_blood_correctionClasses:- Logan_Model"""import numpy as npfrom ..typing_utils import NumpyRealNumberArrayfrom ..arterial import BloodInputfrom ..tac import TACfrom ..kineticmodel import KineticModel_Linear, discrete_integratedef transform_without_blood_correction(cp: NumpyRealNumberArray,                                       ct: NumpyRealNumberArray,                                       t: NumpyRealNumberArray) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    Apply Logan transformation without blood correction.    Parameters:        cp (np.ndarray): Plasma concentration (CP), shape (N,).        ct (np.ndarray): Tissue TAC (CT), shape (N,).        t (np.ndarray): Time points corresponding to frame midpoints, shape (N,).    Returns:        tuple[np.ndarray, np.ndarray]:            - xs (np.ndarray): scaled time, Integrated CP / CT values (RHS of linear fit), shape (N-1,).            - ys (np.ndarray): scaled time, Integrated CT / CT values (LHS of linear fit), shape (N-1,).    """        # integral of cp    intcp = discrete_integrate(cp, t)  # len = N-1        # integral of ct    intct = discrete_integrate(ct, t)  # len = N-1           cts = ct[1:]  # N-1        ys = intct / cts   # len = N-1    xs = intcp / cts   # len = N-1        return xs, ys    def transform_with_blood_correction(cp: NumpyRealNumberArray,                                     cb: NumpyRealNumberArray,                                     ct: NumpyRealNumberArray,                                     t: NumpyRealNumberArray) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    Apply Logan transformation with fixed blood volume correction.    Parameters:        cp (np.ndarray): Plasma concentration (CP), shape (N,).        cb (np.ndarray): Whole blood concentration (CB), shape (N,).        ct (np.ndarray): Tissue TAC (CT), shape (N,).        t (np.ndarray): Time points corresponding to frame midpoints, shape (N,).    Returns:        tuple[np.ndarray, np.ndarray]:            - xs (np.ndarray): scaled time, Integrated CP / corrected CT values (RHS), shape (N-1,).            - ys (np.ndarray): scaled time, Integrated CT / corrected CT values (LHS), shape (N-1,).    """        VB_fixed = 0.05        # blood activity correction    ct_bc = (ct - VB_fixed * cb) / (1-VB_fixed)  # N    cts = ct_bc[1:]    # N-1        # integral of cp    intcp = discrete_integrate(cp, t)  # len = N-1    # integral of ct    intct = discrete_integrate(ct, t)  # len = N-1           ys = intct / cts   # len = N-1    xs = intcp / cts   # len = N-1        return xs, ys                class Logan_Model(KineticModel_Linear):    """    Logan Graphical Model for reversible PET tracer binding.    The Logan model uses linear regression on a transformed TAC curve    to estimate VT (volume of distribution). It can be applied with or    without correction for blood volume effects.    Attributes:        macro_params (dict): Contains 'VT' (volume of distribution).        param_unit (dict): Units for slope, intercept, and VT.        transform_type (str): Type of transformation ('with_blood_correction' or 'without_blood_correction').        name (str): Descriptive name of the model.    """            def __init__(self,                  binput: BloodInput,                  tacs: TAC,                 transform_type: str):        """        Initialize the Logan model.            Parameters:            binput (BloodInput): Blood input object providing CP (and optionally CB).            tacs (TAC): Time-activity curves for one or more ROIs.            transform_type (str): Transformation mode ('with_blood_correction' or 'without_blood_correction').        """                super().__init__(binput, tacs)                        self.macro_params = {'VT': None}                        self.param_unit = {'slope': 'unitless',                           'intercept': '/min',                           'VT': 'unitless'}                self.transform_type = transform_type        self.name = 'Logan'                    def fit(self):        """        Fit the Logan model to each TAC using the specified transformation method.            - Applies Logan transformation (with/without blood correction).        - Performs linear regression for each ROI.        - Extracts VT (volume of distribution) as the macro-parameter from the fitted slope.        """                self.xdata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))        self.ydata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))                t = self.tacs.t        cp = self.inp.CP(t)        cb = self.inp.CB(t)        for i in range(self.tacs.num_elements):            ct = self.tacs.data[i, :]                    if self.transform_type == 'without_blood_correction':                self.xdata[i, :], self.ydata[i, :] = transform_without_blood_correction(cp, ct, t)            elif self.transform_type == 'with_blood_correction':                self.xdata[i, :], self.ydata[i, :] = transform_with_blood_correction(cp, cb, ct, t)                        self.fit_linear()                # set macro params        VT_arr = np.zeros(self.tacs.num_elements)                for i in range(self.tacs.num_elements):            slope = self.get_parameter('slope')[i]                        VT = slope                        VT_arr[i] = VT                self.set_parameter('VT', VT_arr, 'macro')                return None    