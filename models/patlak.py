"""Patlak Graphical Analysis ModelThis module implements the Patlak model for irreversible tracer uptake in PET imaging.It includes two transformation strategies: with and without blood volume correction.The model assumes linear kinetics after a certain time point and fits a linear equationto estimate the influx rate constant (Ki) and initial distribution volume (V0).Functions:- transform_without_blood_correction- transform_with_blood_correctionClasses:- Patlak_Model"""import numpy as npfrom ..typing_utils import NumpyRealNumberArrayfrom ..arterial import BloodInputfrom ..tac import TACfrom ..kineticmodel import KineticModel_Linear, discrete_integratedef transform_without_blood_correction(cp: NumpyRealNumberArray,                                       ct: NumpyRealNumberArray,                                       t: NumpyRealNumberArray) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    Apply Patlak transformation without blood volume correction.    Parameters:        cp (np.ndarray): Plasma concentration (CP), shape (N,).        ct (np.ndarray): Tissue TAC (CT), shape (N,).        t (np.ndarray): Time mid-points of frames, shape (N,).    Returns:        tuple[np.ndarray, np.ndarray]:             - xs (np.ndarray): scaled time, Integrated plasma over CP (RHS of linear fit), shape (N-1,).            - ys (np.ndarray): scaled time, CT / CP (LHS of linear fit), shape (N-1,).    """        # integral of cp    intcp = discrete_integrate(cp, t)  # len = N-1        cps = cp[1:]  # N-1    cts = ct[1:]  # N-1        ys = cts / cps   # len = N-1    xs = intcp / cps   # len = N-1        return xs, ys    def transform_with_blood_correction(cp: NumpyRealNumberArray,                                    cb: NumpyRealNumberArray,                                    ct: NumpyRealNumberArray,                                     t: NumpyRealNumberArray) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    Apply Patlak transformation with fixed blood volume correction.    Parameters:        cp (np.ndarray): Plasma concentration (CP), shape (N,).        cb (np.ndarray): Whole blood concentration (CB), shape (N,).        ct (np.ndarray): Tissue TAC (CT), shape (N,).        t (np.ndarray): Time mid-points of frames, shape (N,).    Returns:        tuple[np.ndarray, np.ndarray]:             - xs (np.ndarray): scaled time, Integrated plasma over CP (RHS of linear fit), shape (N-1,).            - ys (np.ndarray): scaled time, Corrected CT / CP (LHS of linear fit), shape (N-1,).    """        VB_fixed = 0.05        # blood activity correction    ct_bc = (ct - VB_fixed * cb) / (1-VB_fixed)  # N    cts = ct_bc[1:]  # N-1        # integral of cp    intcp = discrete_integrate(cp, t)  # len = N-1        cps = cp[1:]   # N-1        ys = cts / cps     # len = N-1    xs = intcp / cps   # len = N-1        return xs, ys        class Patlak_Model(KineticModel_Linear):    """    Patlak Graphical Analysis Model for irreversible tracer binding.    This model fits a linear relationship between the ratio of tissue to plasma activity and    the normalized integral of plasma activity. It supports both standard and blood-corrected    versions.    Attributes:        macro_params (dict): Contains Ki (slope) and V0 (intercept).        param_unit (dict): Units of slope, intercept, Ki, and V0.        transform_type (str): Type of transformation ('with_blood_correction' or 'without_blood_correction').        name (str): Model name identifier.    """            def __init__(self,                  binput: BloodInput,                  tacs: TAC,                 transform_type: str):        """        Initialize the Patlak model.            Parameters:            binput (BloodInput): Blood input function, provides CP and optionally CB.            tacs (TAC): Time-activity curves for one or more ROIs.            transform_type (str): Type of transformation to apply;                                   either 'without_blood_correction' or 'with_blood_correction'.        """        super().__init__(binput, tacs)                        self.macro_params = {'Ki': None,                             'V0': None}                self.param_unit = {'slope': '/min',                           'intercept': 'unitless',                           'Ki': '/min',                           'V0': 'unitless'}                self.transform_type = transform_type        self.name = 'Patlak'                    def fit(self):        """        Perform Patlak linear regression fitting for each TAC.            This method:        - Applies the selected transformation (with/without blood correction).        - Computes x and y values for each region.        - Fits linear regression and stores the slope and intercept.        - Derives Ki (slope) and V0 (intercept) as macro-parameters.        """                        self.xdata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))        self.ydata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))                for i in range(self.tacs.num_elements):            t = self.tacs.t            cp = self.inp.CP(t)            cb = self.inp.CB(t)            ct = self.tacs.data[i, :]                    if self.transform_type == 'without_blood_correction':                self.xdata[i, :], self.ydata[i, :] = transform_without_blood_correction(cp, ct, t)            elif self.transform_type == 'with_blood_correction':                self.xdata[i, :], self.ydata[i, :] = transform_with_blood_correction(cp, cb, ct, t)                        self.fit_linear()                # set macro params        Ki_arr = np.zeros(self.tacs.num_elements)        V0_arr = np.zeros(self.tacs.num_elements)                for i in range(self.tacs.num_elements):            slope = self.get_parameter('slope')[i]            intercept = self.get_parameter('intercept')[i]                        Ki = slope            V0 = intercept                        Ki_arr[i] = Ki            V0_arr[i] = V0                self.set_parameter('Ki', Ki_arr, 'macro')        self.set_parameter('V0', V0_arr, 'macro')                return None