"""Simplified Reference Tissue Model (SRTM) ImplementationThis module implements nonlinear PET kinetic modeling using variants of theSimplified Reference Tissue Model (SRTM), allowing for parameterization using:- R1, k2, BPND- R1, k2p, k2aFunctions:- model_R1k2BP: SRTM model using parameters R1, k2, BPND.- model_R1k2pk2a: SRTM model using parameters R1, k2p, k2a.Classes:- SRTM_Model: Handles fitting and analysis of PET TACs using SRTM variants."""import numpy as npfrom scipy.signal import convolvefrom ..typing_utils import NumpyRealNumberArrayfrom ..tac import TACfrom ..kineticmodel import KineticModel_NonLineardef model_R1k2BP(reftac: TAC, R1: float, k2: float, BPND: float):    """    SRTM model using R1, k2, and BPND as parameters.    Parameters:        reftac (TAC): Reference region time-activity curve (must be single-element).        R1 (float): Relative delivery (K1/K1p).        k2 (float): Efflux rate constant from target region.        BPND (float): Binding potential, defined as k3/k4.    Returns:        np.ndarray: Simulated TAC using the SRTM equation.    """        k2a = k2/(1+BPND)            t = reftac.t        t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)    # print(f't_upsampled: {t_upsampled}')    # print(f'dt: {dt}')        if reftac.data.shape[0] != 1:        raise ValueError("The reftac.data.shape[0] should be 1")        reftac_upsampled = np.interp(t_upsampled, t, reftac.data.flatten())        conv_upsampled = convolve(reftac_upsampled, np.exp(-k2a * t_upsampled), mode='full')[:len(t_upsampled)] * dt        tac_upsampled = R1 * reftac_upsampled + (k2 - R1 * k2a) * conv_upsampled        tac = np.interp(t, t_upsampled, tac_upsampled)    return tacdef model_R1k2pk2a(reftac: TAC, R1: float, k2p: float, k2a: float):    """    SRTM model using R1, k2p, and k2a as parameters.    Parameters:        reftac (TAC): Reference region time-activity curve (must be single-element).        R1 (float): Relative delivery (K1/K1p).        k2p (float): Efflux rate constant from reference region, = k2/(1+k3/k4) = k2/(1+BP)        k2a (float): Apparent efflux rate constant from target region.    Returns:        np.ndarray: Simulated TAC using the SRTM equation.    """                t = reftac.t        t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)    # print(f't_upsampled: {t_upsampled}')    # print(f'dt: {dt}')        if reftac.data.shape[0] != 1:        raise ValueError("The reftac.data.shape[0] should be 1")        reftac_upsampled = np.interp(t_upsampled, t, reftac.data.flatten())        conv_upsampled = convolve(reftac_upsampled, np.exp(-k2a * t_upsampled), mode='full')[:len(t_upsampled)] * dt        tac_upsampled = R1 * (reftac_upsampled + (k2p - k2a) * conv_upsampled)        tac = np.interp(t, t_upsampled, tac_upsampled)    return tacclass SRTM_Model(KineticModel_NonLinear):    """    Nonlinear Simplified Reference Tissue Model (SRTM) implementation.    Supports fitting with two parameter sets:    - ('R1', 'k2', 'BPND') → derives 'k2a' and 'k2p'    - ('R1', 'k2p', 'k2a') → derives 'k2' and 'BPND'    Attributes:        fitting_func_type (str): Indicates fitting mode ('R1k2BP' or 'R1k2pk2a').        micro_params (dict): Micro-parameters to be fit for each region.        macro_params (dict): Derived parameters computed post-fitting.        param_unit (dict): Units for all parameters.        name (str): Name of the SRTM model variant.    """            def __init__(self,                  reftac: TAC,                  tacs: TAC,                 fitting_func_type: str):        """        Initialize the SRTM model with chosen fitting parameterization.            Parameters:            reftac (TAC): Reference region TAC used for modeling.            tacs (TAC): Target region(s) TACs to be modeled.            fitting_func_type (str): Parameterization scheme ('R1k2BP' or 'R1k2pk2a').        """                super().__init__(reftac, tacs)                self.fitting_func_type = fitting_func_type                    if fitting_func_type == 'R1k2BP':            self.micro_params = {'R1': None,                                  'k2': None,                                 'BPND': None}            self.f_to_fit = model_R1k2BP            self.macro_params = {'k2a': None,                                 'k2p': None}                        self.name = 'SRTM_R1k2BP'                elif fitting_func_type == 'R1k2pk2a':            self.micro_params = {'R1': None,                                  'k2p': None,                                 'k2a': None}            self.f_to_fit = model_R1k2pk2a            self.macro_params = {'k2': None,                                 'BPND': None}                        self.name = 'SRTM_R1k2pk2a'                self.num_micro_params = len(self.micro_params)                        self.param_unit = {'R1': 'unitless',                           'k2': '/min',                           'BPND': 'unitless',                           'k2a': '/min',                           'k2p': '/min'}                    def fit(self,             p0: NumpyRealNumberArray | None = None,            debug: bool | None = None,            special_tissues: list[str] | None = None,            special_p0: NumpyRealNumberArray | None = None):        """        Fit the SRTM model to TAC data and compute derived macro parameters.            Parameters:            p0 (NumpyRealNumberArray | None): Initial guess for micro parameters.            debug (bool | None): Print progress during fitting.            special_tissues (list[str] | None): Tissues requiring custom initial guess.            special_p0 (NumpyRealNumberArray | None): Custom initial guess for special tissues.            Post-Fitting Macro Parameter Calculation:            If 'R1k2BP':                - k2a = k2 / (1 + BPND)                - k2p = k2 / R1            If 'R1k2pk2a':                - k2 = R1 * k2p                - BPND = R1 * (k2p / k2a) - 1        """                        self.fit_nonlinear(p0 = p0,                           debug = debug,                           special_tissues = special_tissues,                           special_p0 = special_p0)        self.generate_fitted_tacs()        self.calculate_fitness_measures()                        # set macro params        if self.fitting_func_type == 'R1k2BP':            k2a_arr = np.zeros(self.tacs.num_elements)            k2p_arr = np.zeros(self.tacs.num_elements)                        for i in range(self.tacs.num_elements):                R1 = self.get_parameter('R1')[i]                k2 = self.get_parameter('k2')[i]                BPND = self.get_parameter('BPND')[i]                                k2a = k2 / (1+BPND)                k2p = k2 / R1                                k2a_arr[i] = k2a                k2p_arr[i] = k2p                        self.set_parameter('k2a', k2a_arr, 'macro')            self.set_parameter('k2p', k2p_arr, 'macro')                                elif self.fitting_func_type == 'R1k2pk2a':                        k2_arr = np.zeros(self.tacs.num_elements)            BPND_arr = np.zeros(self.tacs.num_elements)                        for i in range(self.tacs.num_elements):                R1 = self.get_parameter('R1')[i]                k2p = self.get_parameter('k2p')[i]                k2a = self.get_parameter('k2a')[i]                                k2 = R1 * k2p                BPND = R1 * (k2p/k2a) - 1                                k2_arr[i] = k2                BPND_arr[i] = BPND                        self.set_parameter('k2', k2_arr, 'macro')            self.set_parameter('BPND', BPND_arr, 'macro')                            return None