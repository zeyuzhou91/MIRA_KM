import numpy as npfrom ..arterial import BloodInputfrom ..core import TACfrom .kineticmodel import KineticModel_Linear, discrete_integratefrom ..typing_utils import NumpyRealNumberArraydef transform_without_blood_correction(cp: NumpyRealNumberArray,                                       ct: NumpyRealNumberArray,                                       t: NumpyRealNumberArray) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    cp : plasma tac, len = N    ct : target tissue tac, len = N    t : time array (frame mid points), len = N    Returns    -------    xs: scaled time, independent variable for linear regression, RHS, len = N-1    ys: scaled time, dependent variable for linear regression, LHS, len = N-1    """        # integral of cp    intcp = discrete_integrate(cp, t)  # len = N-1        # integral of ct    intct = discrete_integrate(ct, t)  # len = N-1           cts = ct[1:]  # N-1        ys = intct / cts   # len = N-1    xs = intcp / cts   # len = N-1        return xs, ys    def transform_with_blood_correction(cp: NumpyRealNumberArray,                                     cb: NumpyRealNumberArray,                                     ct: NumpyRealNumberArray,                                     t: NumpyRealNumberArray) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    cp : plasma tac, len = N    cb : whole blood tac, len = N    ct : target tissue tac, len = N    t : time array (frame mid points), len = N    Returns    -------    xs: scaled time, independent variable for linear regression, RHS, len = N-1    ys: scaled time, dependent variable for linear regression, LHS, len = N-1    """        VB_fixed = 0.05        # blood activity correction    ct_bc = (ct - VB_fixed * cb) / (1-VB_fixed)  # N    cts = ct_bc[1:]    # N-1        # integral of cp    intcp = discrete_integrate(cp, t)  # len = N-1    # integral of ct    intct = discrete_integrate(ct, t)  # len = N-1           ys = intct / cts   # len = N-1    xs = intcp / cts   # len = N-1        return xs, ys                class Logan_Model(KineticModel_Linear):    def __init__(self,                  binput: BloodInput,                  tacs: TAC,                 transform_type: str):                super().__init__(binput, tacs)                        self.macro_params = {'VT': None}                        self.param_unit = {'slope': 'unitless',                           'intercept': '/min',                           'VT': 'unitless'}                self.transform_type = transform_type        self.name = 'Logan'                    def fit(self):                self.xdata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))        self.ydata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))                t = self.tacs.t        cp = self.inp.CP(t)        cb = self.inp.CB(t)        for i in range(self.tacs.num_elements):            ct = self.tacs.data[i, :]                    if self.transform_type == 'without_blood_correction':                self.xdata[i, :], self.ydata[i, :] = transform_without_blood_correction(cp, ct, t)            elif self.transform_type == 'with_blood_correction':                self.xdata[i, :], self.ydata[i, :] = transform_with_blood_correction(cp, cb, ct, t)                        self.fit_linear()                # set macro params        VT_arr = np.zeros(self.tacs.num_elements)                for i in range(self.tacs.num_elements):            slope = self.get_parameter('slope')[i]                        VT = slope                        VT_arr[i] = VT                self.set_parameter('VT', VT_arr, 'macro')                return None        # def fit(cp: Callable[[float], float], #         roi: ROI, #         t: NDArray,#         fit_t0 : bool, #         showNsave_plot : bool,#         output_dir : str, #         t0: float | None=None, #         cb: Callable[[float], float] | None=None,#         VB_fixed: float | None=None) -> None:#     """#     cp : function of t. The arterial input function, the plasma activity concentration after metabolite correction. #          t in [min], output in [kBq/mL]#     roi : ROI object.#     t : frame mid points. #     fit_t0 : True - fit variable t0; False - do not fit. #     showNsave_plot : True - show and save plot; False - do not. #     output_dir : output directory. #     t0 : (optional) the start time (in min) of the linear regression. Note: this is the actual time, not the normalized time. #     cb : (optional) function of t. The whole blood activity concentration. #     VB_fixed : (optional) the FIXED fraction of blood volume out of the total tissue volume #     """        #     # sampled cp#     cps = cp(t)    #     # tissue concentration, sampled at frame mid points#     cts = roi.avg_intensity    #     # cps and cts must be sampled at the same time points, i.e. they are of the same length N        #     # blood activity correction (if needed)#     if cb != None and VB_fixed != None:#         # sampled cb#         cbs = cb(t)        #         # correction#         cts = (cts - VB_fixed * cbs) / (1-VB_fixed)    #     # integral of cps#     intcps = aux.discrete_integrate(cps, t)  # len = N-1    #     # integral of cts#     intcts = aux.discrete_integrate(cts, t)  # len = N-1       #     # dependent variable for liner regression, LHS#     ys = intcts / cts[1:]   # len = N-1    #     # independent variable for linear regression, RHS#     xs = intcps / cts[1:]   # len = N-1    #     ts = t[1:]  # len = N-1    #     if (not fit_t0) and (t0 != None):#         # t0 is given, do not fit it        #         # i0: index of the time points in ts that is the closest to t0#         i0 = np.argmin(np.abs(ts - t0))        #         res = linregress(xs[i0:], ys[i0:])#         slope = res.slope#         intercept = res.intercept    #     elif fit_t0:#         # t0 is not given, need to fit it        #         slope, intercept, i0 = tail_linregress(xs, ys)        #         # find t0#         t0 = ts[i0]            #     roi.m = Logan_Model()#     roi.m.params['slope'] = slope#     roi.m.params['intercept'] = intercept#     roi.m.params['tstart'] = t0        #     if showNsave_plot:#         plt.figure()#         plt.scatter(xs[:i0], ys[:i0], facecolors='none', edgecolors='blue')#         plt.scatter(xs[i0:], ys[i0:], facecolors='blue', edgecolors='blue')#         xss = xs[i0:]#         yest = slope * xss + intercept#         plt.plot(xss, yest, c='blue')#         plt.xlabel(r'$\int_0^t C_P(\tau) \, d\tau / C_T(t)$')#         plt.ylabel(r'$\int_0^t C_T(\tau) \, d\tau / C_T(t)$')#         plt.title(f'Logan plot - {roi.name}')#         plt.savefig(os.path.join(output_dir, f'Logan_{roi.name}.png'))#         plt.show()#         plt.close()    #     return None