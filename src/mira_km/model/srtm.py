import numpy as npfrom scipy.signal import convolvefrom ..typing_utils import NumpyRealNumberArrayfrom ..core import TACfrom .kineticmodel import KineticModel_NonLineardef model_R1k2BP(reftac: TAC, R1: float, k2: float, BPND: float):        """    reftac : reference tissue tac    R1 : K1/K1p    BPND : k3/k4    """        k2a = k2/(1+BPND)            t = reftac.t        t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)    # print(f't_upsampled: {t_upsampled}')    # print(f'dt: {dt}')        if reftac.data.shape[0] != 1:        raise ValueError("The reftac.data.shape[0] should be 1")        reftac_upsampled = np.interp(t_upsampled, t, reftac.data.flatten())        conv_upsampled = convolve(reftac_upsampled, np.exp(-k2a * t_upsampled), mode='full')[:len(t_upsampled)] * dt        tac_upsampled = R1 * reftac_upsampled + (k2 - R1 * k2a) * conv_upsampled        tac = np.interp(t, t_upsampled, tac_upsampled)    return tacdef model_R1k2pk2a(reftac: TAC, R1: float, k2p: float, k2a: float):        """    reftac : reference tissue tac    R1 : K1/K1p    k2a = k2/(1+k3/k4) = k2/(1+BP)    """                t = reftac.t        t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)    # print(f't_upsampled: {t_upsampled}')    # print(f'dt: {dt}')        if reftac.data.shape[0] != 1:        raise ValueError("The reftac.data.shape[0] should be 1")        reftac_upsampled = np.interp(t_upsampled, t, reftac.data.flatten())        conv_upsampled = convolve(reftac_upsampled, np.exp(-k2a * t_upsampled), mode='full')[:len(t_upsampled)] * dt        tac_upsampled = R1 * (reftac_upsampled + (k2p - k2a) * conv_upsampled)        tac = np.interp(t, t_upsampled, tac_upsampled)    return tacclass SRTM_Model(KineticModel_NonLinear):    def __init__(self,                  reftac: TAC,                  tacs: TAC,                 fitting_func_type: str):                super().__init__(reftac, tacs)                self.fitting_func_type = fitting_func_type                    if fitting_func_type == 'R1k2BP':            self.micro_params = {'R1': None,                                  'k2': None,                                 'BPND': None}            self.f_to_fit = model_R1k2BP            self.macro_params = {'k2a': None,                                 'k2p': None}                        self.name = 'SRTM_R1k2BP'                elif fitting_func_type == 'R1k2pk2a':            self.micro_params = {'R1': None,                                  'k2p': None,                                 'k2a': None}            self.f_to_fit = model_R1k2pk2a            self.macro_params = {'k2': None,                                 'BPND': None}                        self.name = 'SRTM_R1k2pk2a'                self.num_micro_params = len(self.micro_params)                        self.param_unit = {'R1': 'unitless',                           'k2': '/min',                           'BPND': 'unitless',                           'k2a': '/min',                           'k2p': '/min'}                    def fit(self,             p0: NumpyRealNumberArray | None = None,            debug: bool | None = None,            special_tissues: list[str] | None = None,            special_p0: NumpyRealNumberArray | None = None):                        self.fit_nonlinear(p0 = p0,                           debug = debug,                           special_tissues = special_tissues,                           special_p0 = special_p0)        self.generate_fitted_tacs()        self.calculate_fitness_measures()                        # set macro params        if self.fitting_func_type == 'R1k2BP':            k2a_arr = np.zeros(self.tacs.num_elements)            k2p_arr = np.zeros(self.tacs.num_elements)                        for i in range(self.tacs.num_elements):                R1 = self.get_parameter('R1')[i]                k2 = self.get_parameter('k2')[i]                BPND = self.get_parameter('BPND')[i]                                k2a = k2 / (1+BPND)                k2p = k2 / R1                                k2a_arr[i] = k2a                k2p_arr[i] = k2p                        self.set_parameter('k2a', k2a_arr, 'macro')            self.set_parameter('k2p', k2p_arr, 'macro')                                elif self.fitting_func_type == 'R1k2pk2a':                        k2_arr = np.zeros(self.tacs.num_elements)            BPND_arr = np.zeros(self.tacs.num_elements)                        for i in range(self.tacs.num_elements):                R1 = self.get_parameter('R1')[i]                k2p = self.get_parameter('k2p')[i]                k2a = self.get_parameter('k2a')[i]                                k2 = R1 * k2p                BPND = R1 * (k2p/k2a) - 1                                k2_arr[i] = k2                BPND_arr[i] = BPND                        self.set_parameter('k2', k2_arr, 'macro')            self.set_parameter('BPND', BPND_arr, 'macro')                            return None