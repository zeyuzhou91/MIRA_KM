import numpy as npfrom ..core import TACfrom .kineticmodel import KineticModel_Linear, discrete_integratefrom ..typing_utils import NumpyRealNumberArraydef transform(ref: NumpyRealNumberArray,              ct: NumpyRealNumberArray,              t: NumpyRealNumberArray,              k2p: float) -> (NumpyRealNumberArray, NumpyRealNumberArray):    """    ref : reference tissue tac, len = N    ct : target tissue tac, len = N    t : time array (frame mid points), len = N    k2p: tissue-to-plasma clearance rate of the reference tissue    Returns    -------    xs: scaled time, independent variable for linear regression, RHS, len = N-1    ys: scaled time, dependent variable for linear regression, LHS, len = N-1    """        # integral of ref    intref = discrete_integrate(ref, t)  # len = N-1        # integral of ct    intct = discrete_integrate(ct, t)  # len = N-1         cts = ct[1:]  # N-1    refs = ref[1:]  # N-1            ys = intct / cts   # len = N-1    xs = (intref + refs / k2p) / cts   # len = N-1        return xs, ys                    class LoganRTM_Model(KineticModel_Linear):    def __init__(self,                  reftac: TAC,                  tacs: TAC,                 k2p: float):                super().__init__(reftac, tacs)                        self.k2p = k2p        self.macro_params = {'DVR': None,                             'BPND': None}                self.param_unit = {'slope': 'unitless',                           'intercept': 'min',                           'DVR': 'unitless',                           'BPND': 'unitless'}        self.name = 'LoganRTM'                    def fit(self,             t0: float | None = None,            debug: bool | None = None):        """        t0: start time of linear fitting, [min]        """                self.xdata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))        self.ydata = np.zeros((self.tacs.num_elements, self.tacs.num_frames-1))                t = self.tacs.t        ref = self.inp.data[0, :]        k2p = self.k2p        for i in range(self.tacs.num_elements):            ct = self.tacs.data[i, :]                    self.xdata[i, :], self.ydata[i, :] = transform(ref, ct, t, k2p)                                    self.fit_linear(t0 = t0,                        debug = debug)                        # set macro params        DVR_arr = np.zeros(self.tacs.num_elements)        BPND_arr = np.zeros(self.tacs.num_elements)                for i in range(self.tacs.num_elements):            slope = self.get_parameter('slope')[i]                        DVR = slope            BPND = DVR - 1                        DVR_arr[i] = DVR            BPND_arr[i] = BPND                self.set_parameter('DVR', DVR_arr, 'macro')        self.set_parameter('BPND', BPND_arr, 'macro')                return None    