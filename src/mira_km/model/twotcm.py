import numpy as npfrom scipy.signal import convolvefrom ..typing_utils import NumpyRealNumberArrayfrom ..arterial import BloodInputfrom ..core import TACfrom .kineticmodel import KineticModel_NonLineardef model_without_VB(binput: BloodInput, K1: float, k2: float, k3: float, k4: float):            t = binput.t        g = k2+k3+k4    q = 4*k2*k4    p = np.sqrt(g**2-q)    r = K1/p    c = (g-p)/2.0    d = (g+p)/2.0    a = r*(k3+k4-c)    b = r*(d-k3-k4)        t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)    # print(f't_upsampled: {t_upsampled}')    # print(f'dt: {dt}')        cp_upsampled = binput.CP(t_upsampled)            tac_upsampled = convolve(cp_upsampled, a*np.exp(-c * t_upsampled) + b*np.exp(-d * t_upsampled), mode='full')[:len(t_upsampled)] * dt        tac = np.interp(t, t_upsampled, tac_upsampled)    return tacclass TwoTCM_Model(KineticModel_NonLinear):    def __init__(self,                  binput: BloodInput,                  tacs: TAC,                  fitting_func_type: str):                super().__init__(binput, tacs)                self.fitting_func_type = fitting_func_type        if fitting_func_type == "without_VB":            self.micro_params = {'K1': None,                                'k2': None,                                'k3': None,                                'k4': None}            self.f_to_fit = model_without_VB                    self.macro_params = {'VND': None,                             'VS': None,                             'VT': None,                             'BPND': None}                self.param_unit = {'K1': 'mL/min/mL',                           'k2': '/min',                           'k3': '/min',                           'k4': '/min',                           'VB': 'unitless',                           'VND': 'unitless',                           'VS': 'unitless',                           'VT': 'unitless',                           'BPND': 'unitless'}                        self.name = '2TCM'            def fit(self, p0: NumpyRealNumberArray | None = None):                        self.fit_nonlinear(p0 = p0)        self.generate_fitted_tacs()        self.calculate_fitness_measures()                # set macro params        VND_arr = np.zeros(self.tacs.num_elements)        VS_arr = np.zeros(self.tacs.num_elements)        VT_arr = np.zeros(self.tacs.num_elements)        BPND_arr = np.zeros(self.tacs.num_elements)                for i in range(self.tacs.num_elements):            K1 = self.get_parameter('K1')[i]            k2 = self.get_parameter('k2')[i]            k3 = self.get_parameter('k3')[i]            k4 = self.get_parameter('k4')[i]                        VND = K1/k2            VS = K1*k3/(k2*k4)            VT = K1/k2*(1+k3/k4)            BPND = k3/k4                        VND_arr[i] = VND            VS_arr[i] = VS            VT_arr[i] = VT            BPND_arr[i] = BPND                self.set_parameter('VND', VND_arr, 'macro')        self.set_parameter('VS', VS_arr, 'macro')        self.set_parameter('VT', VT_arr, 'macro')        self.set_parameter('BPND', BPND_arr, 'macro')                return None