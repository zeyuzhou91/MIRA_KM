import osimport matplotlib.pyplot as pltfrom matplotlib.pyplot import cmimport numpy as npimport csvfrom scipy.optimize import curve_fitfrom scipy.stats import linregressfrom sklearn.metrics import mean_squared_errorfrom ..typing_utils import NumpyRealNumberArrayfrom collections.abc import Callablefrom ..arterial import BloodInput#from ..core import TACfrom ..tissue import Ref_Tissue, Tissue_Collections, Input_Collectionsfrom ..frameschedule import FrameSchedulefrom ..tac import TACclass KineticModel:        inp: BloodInput | Ref_Tissue | Input_Collections | None    tcol: Tissue_Collections    fs: FrameSchedule        micro_params: dict[str, NumpyRealNumberArray]    macro_params: dict[str, NumpyRealNumberArray]        param_unit: dict[str, str]        num_micro_params: int    perr: NumpyRealNumberArray  # self.tcol.num_tissues x self.num_micro_params    RMSE: NumpyRealNumberArray  # self.tcol.num_tissues    Rsquared: NumpyRealNumberArray  # self.tcol.num_tissues        name: str   # name of model    def __init__(self,                  inp: BloodInput | Ref_Tissue,                  tcol: Tissue_Collections,                 fs: FrameSchedule) -> None:                self.inp = inp        self.tcol = tcol        self.fs = FrameSchedule        self.micro_params = {}        self.macro_params = {}            self.param_unit = {}                self.num_micro_params = None        self.perr = None        self.RMSE = None        self.Rsquared = None            def get_parameter(self,                       param_name: str,                      ) -> NumpyRealNumberArray:                if param_name in self.micro_params:            param_vector = self.micro_params[param_name]                elif param_name in self.macro_params:            param_vector = self.macro_params[param_name]                    else:            raise ValueError("f{param_name} not found")                    return param_vector            def set_parameter(self,                       param_name: str,                      param: NumpyRealNumberArray,                      param_type: str,                      ) -> None:                if param_type == 'micro':            if param_name in self.micro_params:                self.micro_params[param_name] = param            else:                raise ValueError(f"self.micro_params does not have {param_name}")                    elif param_type == "macro":            if param_name in self.macro_params:                self.macro_params[param_name] = param            else:                raise ValueError(f"self.macro_params does not have {param_name}")                    return None    def print_fitting_results(self):                for i in range(self.tcol.num_tissues):                        tissue = self.tcol.tissues[i]                        print(f"Tissue: {tissue.name}")            print(f"RMSE = {self.RMSE[i]}")            print(f"Rsquared = {self.Rsquared[i]}")                        if isinstance(self, KineticModel_Linear):                print(f"t0 = {self.t0[i]} {self.tissues.tac_t_unit}")                        for j, name in enumerate(self.micro_params.keys()):                                value = self.micro_params[name][i]                stderr = self.perr[i, j]                print(f"{name} = {value} (+/- {stderr}) {self.param_unit[name]}")                            for j, name in enumerate(self.macro_params.keys()):                                value = self.macro_params[name][i]                print(f"{name} = {value} {self.param_unit[name]}")                        print("")        return None            def plot_tacs(self,                  tissue_names: list[str],                  add_input: bool,                   title: str | None = None,                  xlim: list[float] | tuple[float] | None = None,                  ylim: list[float] | tuple[float] | None = None,                  op_dir: str | None = None,                  op_filename: str | None = None) -> None:                if tissue_names is None or (len(tissue_names) == 1 and tissue_names[0] == 'all'):            tissues_to_plot = self.tcol.tissues        else:            tissues_to_plot = []            for name in tissue_names:                tissues_to_plot.append(self.tcol.tissue_by_name(name))                                colors = cm.rainbow(np.linspace(0, 1, len(tissues_to_plot)))                plt.figure()        for (k, tissue) in enumerate(tissues_to_plot):            color = colors[k].reshape(1,-1)                        ts = tissue.tac.t            ys = tissue.tac.y            plt.scatter(ts, ys, c=color, label= f'{tissue.name} ({tissue.num_voxels})')                    #plt.plot(ts, ys, '-o', c=color, label= f'{tissue.name} ({tissue.num_voxels})')                #######################################################################        # without this block, the plotting function is essentially the same as self.tissues.plot_tacs()        if add_input:                        color = "black"            ts = self.fs.mid_points            if isinstance(self.inp, BloodInput):                ys = self.inp.CP(ts)                plt.plot(ts, ys, c=color, label='Input: Blood')            elif isinstance(self.inp, Ref_Tissue):                ys = self.inp.tac.y                plt.scatter(ts, ys, c=color, label=f"Input Ref: {self.inp.name}")        #######################################################################                                        plt.xlabel(f't ({self.tcol.tac_t_unit})')        plt.ylabel(f'{self.tcol.tac_y_unit}')                if xlim is not None:            if xlim[0] is not None:                plt.xlim(xmin = xlim[0])            if xlim[1] is not None:                plt.xlim(xmax = xlim[1])        if ylim is not None:            if ylim[0] is not None:                plt.ylim(ymin = ylim[0])            if ylim[1] is not None:                plt.ylim(ymax = ylim[1])                if title is None:            plt.title('TACs')        else:            plt.title(title)        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))        plt.grid()        if op_dir is not None:            if op_filename is None:                opfile_path = os.path.join(op_dir, 'tac.png')            else:                opfile_path = os.path.join(op_dir, op_filename)            plt.savefig(opfile_path, bbox_inches="tight", dpi=300)        plt.show()        plt.close()                return None             def export_fitting_results(self,                                op_dir: str,                               op_name_suffix: str | None = None) -> None:        """        Export kinetic modeling parameters to an csv file.         """                if op_name_suffix is None:            opfile_path = os.path.join(op_dir, f'{self.name}.csv')        else:            opfile_path = os.path.join(op_dir, f'{self.name}{op_name_suffix}')                header_row = ['Tissue']        unit_row = ['']                for i, name in enumerate(self.micro_params.keys()):            header_row.append(name)            unit_row.append(self.param_unit[name])                        header_row.append(name + ' stderr')            unit_row.append(self.param_unit[name])                    for name in self.macro_params.keys():            header_row.append(name)            unit_row.append(self.param_unit[name])                                        header_row.append('RMSE')        unit_row.append(self.tcol.tac_y_unit)                header_row.append('Rsquared')        unit_row.append('unitless')                if isinstance(self, KineticModel_Linear):            header_row.append('t0')            unit_row.append(f'{self.tcol.tac_t_unit}')                # Writing to CSV file        with open(opfile_path, 'w', newline='') as csvfile:            # Create a CSV writer object            csv_writer = csv.writer(csvfile)                            # Write the header row            csv_writer.writerow(header_row)                        # Write the unit row            csv_writer.writerow(unit_row)                        for j in range(self.tcol.num_tissues):                tissue_params = []                                for i, name in enumerate(self.micro_params.keys()):                    tissue_params.append(self.micro_params[name][j])                    tissue_params.append(self.perr[j][i])                                        for name in self.macro_params.keys():                    tissue_params.append(self.macro_params[name][j])                                tissue_params.append(self.RMSE[j])                tissue_params.append(self.Rsquared[j])                                if isinstance(self, KineticModel_Linear):                    tissue_params.append(self.t0[j])                                row = [self.tcol.tissues[j].name] + tissue_params                csv_writer.writerow(row)                        return None    class KineticModel_NonLinear(KineticModel):        f_to_fit: Callable[..., float]    f_for_fitting_plot: Callable[..., float]    def __init__(self,                  inp: BloodInput | Ref_Tissue | Input_Collections | None,                 tcol: Tissue_Collections,                 fs: FrameSchedule) -> None:                super().__init__(inp = inp,                         tcol = tcol,                         fs = fs)        self.f_to_fit = None        self.f_for_fitting_plot = None        self.micro_params_mat = None                    def fit_nonlinear(self,                       p0: NumpyRealNumberArray | None = None,                      bounds: tuple | None = None,                       weights: NumpyRealNumberArray | None = None,                      exclude_points_at: list | None = None,                      debug: bool | None = None,                      special_tissues: list[str] | None = None,                      special_p0: NumpyRealNumberArray | None = None):        """        special_tissues are those that need special_p0 in curve_fit.                 Exclude points indexed by exclude_points_at. Currently this only works        for inp = None.         """                self.num_micro_params = len(self.micro_params)        self.perr = np.zeros((self.tcol.num_tissues, self.num_micro_params))                # Each row for one tissue, e.g. putamen        # Each column for one micro parameter, e.g. K1, k2        self.micro_params_mat = np.zeros((self.tcol.num_tissues, self.num_micro_params))                        # loop through tissues        for i in range(self.tcol.num_tissues):                        if debug:                print(self.tcol.tissues[i].name)                        if special_tissues is not None and self.tcol.tissues[i].name in special_tissues:                if special_p0 is not None:                    myp0 = special_p0                else:                    raise ValueError(f'{self.tcol.tissues[i].name} is among the special tissues, but special_p0 is not specified.')                        elif p0 is None:                myp0 = np.ones(self.num_micro_params)  # initial guess                            else:                myp0 = p0                        if debug:                print(myp0)                        if self.inp is None:                xdata = self.tcol.tissues[i].tac.t                 if exclude_points_at is not None:                    xdata = np.delete(xdata, exclude_points_at)                            else:                xdata = self.inp                            ydata = self.tcol.tissues[i].tac.y            if exclude_points_at is not None:                ydata = np.delete(ydata, exclude_points_at)                        if weights is None:                sigma = None            else:                sigma = 1.0/weights                                    if bounds is None:                popt, pcov = curve_fit(f = self.f_to_fit,                                        xdata = xdata,                                       ydata = ydata,                                        p0 = myp0,                                       sigma = sigma)            else:                popt, pcov = curve_fit(f = self.f_to_fit,                                        xdata = xdata,                                       ydata = ydata,                                        p0 = myp0,                                       sigma = sigma,                                        bounds = bounds)                        self.micro_params_mat[i, :] = popt                        self.perr[i, :] = np.sqrt(np.diag(pcov))        for j, param_name in enumerate(self.micro_params.keys()):            self.set_parameter(param_name, self.micro_params_mat[:, j], 'micro')                        return None    def generate_fitted_tacs(self):                                    for i in range(self.tcol.num_tissues):                        tissue = self.tcol.tissues[i]                        micro_params = self.micro_params_mat[i, :]                        if self.inp is None:                inp = self.tcol.tissues[i].tac.t            else:                inp = self.inp                            fitted = self.f_to_fit(inp, *micro_params)                        tissue.fitted_tac = TAC(t = tissue.tac.t,                                    y = fitted,                                    unit = tissue.tac.unit,                                    t_unit = tissue.tac.t_unit)                    return None        def plot_tacs_with_fitting(self,                  tissue_names: list[str],                  add_input: bool,                   title: str | None = None,                  xlim: list[float] | tuple[float] | None = None,                  ylim: list[float] | tuple[float] | None = None,                  op_dir: str | None = None,                  op_filename: str | None = None) -> None:                if tissue_names is None or (len(tissue_names) == 1 and tissue_names[0] == 'all'):            tissues_to_plot = self.tcol.tissues        else:            tissues_to_plot = []            for name in tissue_names:                tissues_to_plot.append(self.tcol.tissue_by_name(name))                                colors = cm.rainbow(np.linspace(0, 1, len(tissues_to_plot)))                plt.figure()        for (k, tissue) in enumerate(tissues_to_plot):            color = colors[k].reshape(1,-1)                        ts = tissue.tac.t            ys = tissue.tac.y            plt.scatter(ts, ys, c=color, label= f'{tissue.name} ({tissue.num_voxels})')                                    N = 256            ts_upsampled = np.linspace(min(0, np.min(ts)), np.max(ts), N)            tissue_index = self.tcol.index_by_name(tissue.name)            tissue_micro_params = self.micro_params_mat[tissue_index, :]            if self.inp is None:                ys_upsampled = self.f_to_fit(ts_upsampled, *tissue_micro_params)            else:                inp = self.inp                ys_upsampled = self.f_for_fitting_plot(inp, ts_upsampled, *tissue_micro_params)            plt.plot(ts_upsampled, ys_upsampled, c=color)                #######################################################################        if add_input:                        color = "black"            ts = self.fs.mid_points            if isinstance(self.inp, BloodInput):                ys = self.inp.CP(ts)                plt.plot(ts, ys, c=color, label='Input: Blood')            elif isinstance(self.inp, Ref_Tissue):                ys = self.inp.tac.y                plt.scatter(ts, ys, c=color, label=f"Input Ref: {self.inp.name}")        #######################################################################                                        plt.xlabel(f't ({self.tcol.tac_t_unit})')        plt.ylabel(f'{self.tcol.tac_y_unit}')                if xlim is not None:            if xlim[0] is not None:                plt.xlim(xmin = xlim[0])            if xlim[1] is not None:                plt.xlim(xmax = xlim[1])        if ylim is not None:            if ylim[0] is not None:                plt.ylim(ymin = ylim[0])            if ylim[1] is not None:                plt.ylim(ymax = ylim[1])                if title is None:            plt.title('TACs')        else:            plt.title(title)        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))        plt.grid()        if op_dir is not None:            if op_filename is None:                opfile_path = os.path.join(op_dir, 'tac.png')            else:                opfile_path = os.path.join(op_dir, op_filename)            plt.savefig(opfile_path, bbox_inches="tight", dpi=300)        #plt.show()        plt.close()                return None    def calculate_fitness_measures(self):                self.RMSE = np.zeros(self.tcol.num_tissues)        self.Rsquared = np.zeros(self.tcol.num_tissues)                for i in range(self.tcol.num_tissues):                        tissue = self.tcol.tissues[i]                        error = tissue.tac.y - tissue.fitted_tac.y            SE = np.square(error)  # squared errors            MSE = np.mean(SE)  # mean squared errors            self.RMSE[i] = np.sqrt(MSE)  # root mean squared error            self.Rsquared[i] = 1.0 - (np.var(error) / np.var(tissue.tac.y))                    return None                class KineticModel_Linear(KineticModel):        ##### TO UPDATE: 2024-10-20 ###############################################            # transformed x data: (self.tcol.num_tissues) x (self.tacs.num_frames - 1)    xdata: NumpyRealNumberArray    # transformed y data: (self.tacs.num_elements) x (self.tacs.num_frames - 1)    ydata: NumpyRealNumberArray        # Note: xdata and ydata has -1 in length compared to self.tacs.num_frames    # because they are calculated by transformations from tacs, often involved    # with discrete integrals, which reduce the length by one.         # i0, index of the first point of the linear line: len = self.tcol.num_tissues    i0: NumpyRealNumberArray        # t0, time of the first point of the linear line: len = self.tcol.num_tissues    t0: NumpyRealNumberArray            # Optional for future: making it user defined    MAX_ERR: float        def __init__(self,                  inp: BloodInput | TAC,                  tacs: TAC) -> None:                super().__init__(inp = inp,                         tacs = tacs)                self.xdata = None        self.ydata = None        self.i0 = np.zeros(self.tacs.num_elements, dtype=int)        self.t0 = np.zeros(self.tacs.num_elements)                self.micro_params = {'slope': None,                              'intercept': None}                self.num_micro_params = len(self.micro_params)        self.perr = np.zeros((self.tacs.num_elements, self.num_micro_params))                self.MAX_ERR = 0.03                     def fit_linear(self,                    t0: float | None = None,                   debug: bool | None = None):        """        t0: the starting time of linear fitting, [min]        """                self.RMSE = np.zeros(self.tacs.num_elements)        self.Rsquared = np.zeros(self.tacs.num_elements)                slope_arr = np.zeros(self.tacs.num_elements)        intercept_arr = np.zeros(self.tacs.num_elements)                        if t0 is None:            # t0 is not given, need to fit it                        for j in range(self.tacs.num_elements):                                if debug:                    print(self.tacs.rois[j].name)                                res, i0, rmse = tail_linregress(self.xdata[j,:], self.ydata[j,:], self.MAX_ERR)                #print(f'type of i0: {type(i0)}')                                slope_arr[j] = res.slope                intercept_arr[j] = res.intercept                                self.perr[j, 0] = res.stderr  # stderr of slope                self.perr[j, 1] = res.intercept_stderr                                self.RMSE[j] = rmse                self.Rsquared[j] = (res.rvalue)**2                                self.i0[j] = i0                                # i0 is the index in a row of xdata or ydata, which has length self.tacs.num_frames-1                # self.tacs.t has length self.tacs.num_frames                # So we use i0+1                t0 = self.tacs.t[i0+1]                self.t0[j] = t0                        else:            # t0 is given, do not fit it                        for j in range(self.tacs.num_elements):                                if debug:                    print(self.tacs.rois[j].name)                                self.t0[j] = t0                                # i0: index of the time points in ts that is the closest to t0                i0 = np.argmin(np.abs(self.tacs.t - t0))                self.i0[j] = i0                            xs = self.xdata[j, i0:]                ys = self.ydata[j, i0:]                                res = linregress(xs, ys)                                slope = res.slope                intercept = res.intercept                            yest = slope * xs + intercept                                rmse = mean_squared_error(y_true=ys, y_pred=yest, squared=True)                                slope_arr[j] = res.slope                intercept_arr[j] = res.intercept                                self.perr[j, 0] = res.stderr  # stderr of slope                self.perr[j, 1] = res.intercept_stderr                                self.RMSE[j] = rmse                self.Rsquared[j] = (res.rvalue)**2                self.set_parameter('slope', slope_arr, 'micro')        self.set_parameter('intercept', intercept_arr, 'micro')            return None            def plot_fitting(self,                      tissue_names: list[str],                      op_dir: str | None = None) -> None:                tissues_all = [roi.name for roi in self.tacs.rois]        tissues_to_plot = []        tissues_not_available = []                if len(tissue_names) == 1 and tissue_names[0] == 'all':            tissues_to_plot = tissues_all        else:            for tissue in tissue_names:                 if tissue in tissues_all:                     tissues_to_plot.append(tissue)                 else:                     tissues_not_available.append(tissue)                for tissue in tissues_to_plot:             k = tissues_all.index(tissue)                          xs = self.xdata[k, :]             ys = self.ydata[k, :]             i0 = self.i0[k]             #print(f'type of i0: {type(i0)}')             slope = self.get_parameter('slope')[k]             intercept = self.get_parameter('intercept')[k]                                      plt.figure()             plt.scatter(xs[:i0], ys[:i0], facecolors='none', edgecolors='blue')             plt.scatter(xs[i0:], ys[i0:], facecolors='blue', edgecolors='blue')             xss = xs[i0:]             yest = slope * xss + intercept             plt.plot(xss, yest, c='blue')             plt.xlabel('x')             plt.ylabel('y')             plt.title(f'{self.name}: {tissue}')             if op_dir is not None:                 plt.savefig(os.path.join(op_dir, f'{self.name}_{tissue}.png'))             plt.show()             plt.close()                            for tissue in tissues_not_available:            print(f"{tissue}'s data not available")                            return None    # class KineticModel_Linear2(KineticModel):    #     # fitted_tacs: TAC#     # f_to_fit: Callable[..., float]    #     # transformed x data: (self.tacs.num_elements) x (self.tacs.num_frames - 1)#     xdata: NumpyRealNumberArray#     # transformed y data: (self.tacs.num_elements) x (self.tacs.num_frames - 1)#     ydata: NumpyRealNumberArray    #     # Note: xdata and ydata has -1 in length compared to self.tacs.num_frames#     # because they are calculated by transformations from tacs, often involved#     # with discrete integrals, which reduce the length by one.     #     # i0, index of the first point of the linear line: len = self.tacs.num_elements#     i0: NumpyRealNumberArray    #     # t0, time of the first point of the linear line: len = self.tacs.num_elements#     t0: NumpyRealNumberArray        #     # Optional for future: making it user defined#     MAX_ERR: float    #     def __init__(self, #                  inp: BloodInput | TAC, #                  tacs: TAC) -> None:        #         super().__init__(inp = inp,#                          tacs = tacs)        #         self.xdata = None#         self.ydata = None#         self.i0 = np.zeros(self.tacs.num_elements, dtype=int)#         self.t0 = np.zeros(self.tacs.num_elements)        #         self.micro_params = {'slope': None, #                              'intercept': None}        #         self.num_micro_params = len(self.micro_params)#         self.perr = np.zeros((self.tacs.num_elements, self.num_micro_params))        #         self.MAX_ERR = 0.03                 #     def fit_linear(self, #                    t0: float | None = None,#                    debug: bool | None = None):#         """#         t0: the starting time of linear fitting, [min]#         """        #         self.RMSE = np.zeros(self.tacs.num_elements)#         self.Rsquared = np.zeros(self.tacs.num_elements)        #         slope_arr = np.zeros(self.tacs.num_elements)#         intercept_arr = np.zeros(self.tacs.num_elements)                #         if t0 is None:#             # t0 is not given, need to fit it            #             for j in range(self.tacs.num_elements):                #                 if debug:#                     print(self.tacs.rois[j].name)                #                 res, i0, rmse = tail_linregress(self.xdata[j,:], self.ydata[j,:], self.MAX_ERR)#                 #print(f'type of i0: {type(i0)}')                #                 slope_arr[j] = res.slope#                 intercept_arr[j] = res.intercept                #                 self.perr[j, 0] = res.stderr  # stderr of slope#                 self.perr[j, 1] = res.intercept_stderr                #                 self.RMSE[j] = rmse#                 self.Rsquared[j] = (res.rvalue)**2                #                 self.i0[j] = i0                #                 # i0 is the index in a row of xdata or ydata, which has length self.tacs.num_frames-1#                 # self.tacs.t has length self.tacs.num_frames#                 # So we use i0+1#                 t0 = self.tacs.t[i0+1]#                 self.t0[j] = t0                #         else:#             # t0 is given, do not fit it            #             for j in range(self.tacs.num_elements):                #                 if debug:#                     print(self.tacs.rois[j].name)                #                 self.t0[j] = t0                #                 # i0: index of the time points in ts that is the closest to t0#                 i0 = np.argmin(np.abs(self.tacs.t - t0))#                 self.i0[j] = i0            #                 xs = self.xdata[j, i0:]#                 ys = self.ydata[j, i0:]                #                 res = linregress(xs, ys)                #                 slope = res.slope#                 intercept = res.intercept            #                 yest = slope * xs + intercept                #                 rmse = mean_squared_error(y_true=ys, y_pred=yest, squared=True)                #                 slope_arr[j] = res.slope#                 intercept_arr[j] = res.intercept                #                 self.perr[j, 0] = res.stderr  # stderr of slope#                 self.perr[j, 1] = res.intercept_stderr                #                 self.RMSE[j] = rmse#                 self.Rsquared[j] = (res.rvalue)**2        #         self.set_parameter('slope', slope_arr, 'micro')#         self.set_parameter('intercept', intercept_arr, 'micro')    #         return None        #     def plot_fitting(self, #                      tissue_names: list[str], #                      op_dir: str | None = None) -> None:        #         tissues_all = [roi.name for roi in self.tacs.rois]#         tissues_to_plot = []#         tissues_not_available = []        #         if len(tissue_names) == 1 and tissue_names[0] == 'all':#             tissues_to_plot = tissues_all#         else:#             for tissue in tissue_names:#                  if tissue in tissues_all:#                      tissues_to_plot.append(tissue)#                  else:#                      tissues_not_available.append(tissue)        #         for tissue in tissues_to_plot:#              k = tissues_all.index(tissue)             #              xs = self.xdata[k, :]#              ys = self.ydata[k, :]#              i0 = self.i0[k]#              #print(f'type of i0: {type(i0)}')#              slope = self.get_parameter('slope')[k]#              intercept = self.get_parameter('intercept')[k]                         #              plt.figure()#              plt.scatter(xs[:i0], ys[:i0], facecolors='none', edgecolors='blue')#              plt.scatter(xs[i0:], ys[i0:], facecolors='blue', edgecolors='blue')#              xss = xs[i0:]#              yest = slope * xss + intercept#              plt.plot(xss, yest, c='blue')#              plt.xlabel('x')#              plt.ylabel('y')#              plt.title(f'{self.name}: {tissue}')#              if op_dir is not None:#                  plt.savefig(os.path.join(op_dir, f'{self.name}_{tissue}.png'))#              plt.show()#              plt.close()                    #         for tissue in tissues_not_available:#             print(f"{tissue}'s data not available")                    #         return None            def tail_linregress(xs: NumpyRealNumberArray,                     ys: NumpyRealNumberArray,                    MAX_ERR: float) -> (..., int):    """    Find the best linear fit of the tail of the given data.         Assume the data (ys vs xs) is generally increasing, either concave of convex,     not of some bizarre shape.     """        N = len(xs)        for i in range(N-1):        xss = xs[i:]        yss = ys[i:]        #M = len(xss)                res = linregress(xss, yss)            slope = res.slope        intercept = res.intercept            yest = slope * xss + intercept                # root mean squared error        rmse = mean_squared_error(y_true=yss, y_pred=yest, squared=True)                # mean absolute percentage error        mape = np.mean(np.abs((yest - yss) / yss))                if mape < MAX_ERR:            break                #print(f'i = {i}, M = {M}, MAPE = {mape}')        return res, i, rmsedef discrete_integrate(f: NumpyRealNumberArray, t: NumpyRealNumberArray) -> NumpyRealNumberArray:    """    Integration of the curve defined by sampled points.     Parameters    ----------    f : sampled values of the curve, length N    t : time stamps of sampling, length N    Returns    -------    intf : integration of f over t, length N-1    """        # Basically, we just find the areas of a series of trapezoids and     # accumulatively add them together            dt = t[1:] - t[:-1]        top = f[:-1]  # trapezoid top sides    bottom = f[1:]  # trapezoid bottom sides        # areas of trapezoids     areas = (top + bottom) * dt / 2.0        # cumulative sum of areas    intf = np.cumsum(areas)        return intf